<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OSRD – Choix techniques et phyiques</title><link>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/</link><description>Recent content in Choix techniques et phyiques on OSRD</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/index.xml" rel="self" type="application/rss+xml"/><item><title>Users: Architecture de l'outil OSRD</title><link>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/architecture/</guid><description>
&lt;h4 id="schéma-de-larchitecture-du-logiciel-osrd">Schéma de l&amp;rsquo;architecture du logiciel OSRD&lt;/h4>
&lt;p>Il s’agit d’une architecture multi-services où plusieurs composants logiciels interagissent entre eux. Ce choix a été fait pour assurer la modularité du code et pour garantir l’exploitabilité de certains services d’OSRD par des applications extérieures.&lt;/p>
&lt;p>&lt;img src="architecture.svg" alt="Architecture">&lt;/p></description></item><item><title>Users: Modélisation physique</title><link>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/physic_modelisation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/physic_modelisation/</guid><description>
&lt;!-- script to auto-render KaTeX extension -->
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous">&lt;/script>
&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
onload="renderMathInElement(document.body);">&lt;/script>
&lt;h4 id="le-principe-fondamental-de-la-dynamique">Le principe fondamental de la dynamique&lt;/h4>
&lt;p>Pour calculer l’accélération du train il faut considérer toutes les forces appliquées : $$ \sum \vec{F}=m\vec{a} $$&lt;/p>
&lt;p>&lt;img src="../forces.png?style=train" alt="Marche">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Traction&lt;/strong> : Les valeurs de la force de traction $F_{mot}$ pour chaque position sont dépendantes du type de matériel roulant et de la vitesse $v^{\prime}_x$. La dépendance de la vitesse est exprimée par la courbe effort/vitesse à la jante.&lt;/li>
&lt;/ul>
&lt;p>$$ F_{mot}(\vec{v^{\prime}}&lt;em>x,x^{\prime})=F&lt;/em>{mot}(v^{\prime}_x,x^{\prime}){\vec{e_x}^{\prime}} $$&lt;/p>
&lt;p>&lt;img src="../effort-vitesse.png" alt="Marche">&lt;/p>
&lt;blockquote>
&lt;p>L&amp;rsquo;axe &lt;strong>x&lt;/strong> représente la vitesse du train en [km/h], l&amp;rsquo;axe &lt;strong>y&lt;/strong>, la valeur de la force de traction en [kN].&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>Freinage&lt;/strong> : Les valeurs de la force de freinage $F_{brk}$ dépendent du type de matériel roulant et peuvent être dépendantes de la vitesse ou avoir une valeur constante.&lt;/li>
&lt;/ul>
&lt;p>$$ \vec{F_{brk}}(x^{\prime})=-F_{brk}(x^{\prime}){\vec{e_x}^{\prime}} $$&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Résistance à l&amp;rsquo;avancement&lt;/strong> : Pour modéliser la résistance à l’ avancement du train on utilise la formule de Davis qui prend en compte tous les frottements et la résistance aérodynamique de l’air. La valeur de la resistance à l&amp;rsquo;avancement dépend de la vitesse $v^{\prime}_x$. Les coefficient $A$, $B$, $C$ dépendent du type de matériel roulant.&lt;/li>
&lt;/ul>
&lt;p>$$ \vec{R(v^{\prime}_x)}=-(A+Bv^{\prime}_x+{Cv^{\prime}_x}^2){\vec{e_x}^{\prime}} $$&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Poids (pentes + virages)&lt;/strong> : La force du poids donnée par le produit entre la masse $m$ du train et la constante gravitationnelle $g$ est projectée sur les axes $\vec{e_x}^{\prime}$ et $\vec{e_y}^{\prime}$. Pour la projection, on utilise l&amp;rsquo;angle $i(x^{\prime})$, qui est calculé à partir de l&amp;rsquo;angle de déclivité $s(x^{\prime})$ corrigé par un facteur qui prend en compte l&amp;rsquo;effet du rayon de virage $r(x^{\prime})$.&lt;/li>
&lt;/ul>
&lt;p>$$ \vec{P(x^{\prime})}=-mge_y(\vec{x^{\prime}})=-mg\Big[sin\big(i(x^{\prime})\big){\vec{e_x}^{\prime}}+cos\big(i(x^{\prime})\big){\vec{e_y}^{\prime}}\Big] $$
$$ i(x^{\prime})= s(x^{\prime})+\frac{800m}{r(x^{\prime})} $$&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Réaction du sol&lt;/strong> :&lt;/li>
&lt;/ul>
&lt;p>$$ \vec{R_{gnd}}=R_{gnd}{\vec{e_y}^{\prime}} $$&lt;/p></description></item><item><title>Users: Quelle méthode d'intégration l'outil OSRD doit-il utiliser ?</title><link>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/which_method/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/which_method/</guid><description>
&lt;!-- script to auto-render KaTeX extension -->
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous">&lt;/script>
&lt;script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
onload="renderMathInElement(document.body);">&lt;/script>
&lt;h4 id="introduction">Introduction&lt;/h4>
&lt;p>OSRD, en tant que simulateur d&amp;rsquo;exploitation de train, doit être capable de simuler la physique d&amp;rsquo;un voyage en train. L&amp;rsquo;accélération du train étant influencée par de nombreux facteurs différents changeant le long du trajet (pente, courbure, force de traction du moteur&amp;hellip;), la simulation doit être séparée en étapes suffisamment petites pour considérer tous ces facteurs comme constants, puis utiliser l&amp;rsquo;équation du mouvement de Newton pour calculer le déplacement et la vitesse du train. La méthode d&amp;rsquo;Euler est la plus simple pour calculer ces paramètres, mais elle présente un certain nombre d&amp;rsquo;inconvénients. Cet article explique la méthode d&amp;rsquo;Euler, pourquoi elle ne convient pas aux besoins d&amp;rsquo;OSRD et quelle méthode d&amp;rsquo;intégration doit être utilisée pour la remplacer.&lt;/p>
&lt;h4 id="la-méthode-deuler">La méthode d&amp;rsquo;Euler&lt;/h4>
&lt;h5 id="avec-des-pas-de-temps">Avec des pas de temps&lt;/h5>
&lt;p>La méthode d&amp;rsquo;Euler appliquée à l&amp;rsquo;intégration de l&amp;rsquo;équation du mouvement d&amp;rsquo;un train est :&lt;/p>
&lt;p>$$v_{n+1}=\gamma_n(v_n)dt+v_n$$ &lt;div style="text-align: center"> &lt;strong>(1)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$x_{n+1}=\frac{1}{2}\gamma_n(v_n)dt^2+v_ndt+x_n$$ &lt;div style="text-align: center"> &lt;strong>(2)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Avec :&lt;/p>
&lt;ul>
&lt;li>&lt;em>v&lt;sub>n+1&lt;/sub>&lt;/em> : vitesse calculée au pas &lt;strong>n+1&lt;/strong>&lt;/li>
&lt;li>&lt;em>γ&lt;sub>n&lt;/sub>(v&lt;sub>n&lt;/sub>)&lt;/em> : accélération calculée au pas &lt;strong>n&lt;/strong>&lt;/li>
&lt;li>&lt;em>v&lt;sub>n&lt;/sub>&lt;/em> : vitesse calculée à l&amp;rsquo;étape &lt;strong>n&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h5 id="avec-des-pas-de-distance">Avec des pas de distance&lt;/h5>
&lt;p>Au lieu d&amp;rsquo;utiliser un pas de temps &lt;em>dt&lt;/em>, nous séparons le calcul par des pas de distance &lt;em>h&lt;/em>. Ainsi, en utilisant l&amp;rsquo;équation d&amp;rsquo;intégration temporelle &lt;strong>(2)&lt;/strong> ci-dessus, sachant que &lt;em>x&lt;sub>n+1&lt;/sub>-x&lt;sub>n&lt;/sub>=h&lt;/em>, nous obtenons :&lt;/p>
&lt;p>$$dt=-\frac{v_n}{\gamma_n(v_n)}+\sqrt{(\frac{v_n}{\gamma_n(v_n)})^2+\frac{2h}{\gamma_n(v_n)}}$$ &lt;div style="text-align: center"> &lt;strong>(3)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Et en utilisant &lt;strong>(1)&lt;/strong>, en remplaçant &lt;em>dt&lt;/em>, on obtient :&lt;/p>
&lt;p>$$v_{n+1}=\sqrt{v^2_n+2h\gamma_n(v_n)}$$ &lt;div style="text-align: center"> &lt;strong>(4)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Et puis simplement :
$$x_{n+1}=x_n+h$$ &lt;div style="text-align: center"> &lt;strong>(5)&lt;/strong> &lt;/div>&lt;/p>
&lt;h4 id="pourquoi-la-méthode-deuler-utilisant-lintégration-temporelle-ne-convient-elle-pas-à-nos-besoins-">Pourquoi la méthode d&amp;rsquo;Euler utilisant l&amp;rsquo;intégration temporelle ne convient-elle pas à nos besoins ?&lt;/h4>
&lt;p>La méthode d&amp;rsquo;intégration d&amp;rsquo;Euler dans le temps présente un certain nombre de problèmes :&lt;/p>
&lt;ul>
&lt;li>Comme on intègre dans le temps, on ne peut retrouver que les conditions du point de départ de l&amp;rsquo;étape d&amp;rsquo;intégration (pente, paramètres d&amp;rsquo;infrastructure, etc.) car on ne sait pas où elle se termine&lt;/li>
&lt;li>Elle ne permet pas d&amp;rsquo;anticiper les futurs changements de directive : nous ne pouvons réagir qu&amp;rsquo;en comparant l&amp;rsquo;état actuel du train à ce qu&amp;rsquo;il est censé être&lt;/li>
&lt;li>La méthode actuelle génère beaucoup de données, car il y a beaucoup d&amp;rsquo;étapes d&amp;rsquo;intégration&lt;/li>
&lt;/ul>
&lt;h4 id="la-méthode-deuler-cauchy">La méthode d&amp;rsquo;Euler-Cauchy&lt;/h4>
&lt;h5 id="avec-des-pas-de-temps-1">Avec des pas de temps&lt;/h5>
&lt;p>La méthode Euler-Cauchy appliquée à l&amp;rsquo;intégration de l&amp;rsquo;équation du mouvement d&amp;rsquo;un train est :&lt;/p>
&lt;p>$$v^*_{n+1}=\gamma_n(v_n)dt+v_n$$ &lt;div style="text-align: center"> &lt;strong>(6)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$\gamma=\frac{\gamma_n(v_n)+\gamma_{n+1}(v^*_{n+1})}{2}$$ &lt;div style="text-align: center"> &lt;strong>(7)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$v_{n+1}=\gamma dt+v_n$$ &lt;div style="text-align: center"> &lt;strong>(8)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Elle fonctionne de la même manière que la méthode d&amp;rsquo;Euler, mais en remplaçant l&amp;rsquo;accélération à l&amp;rsquo;étape &lt;strong>n&lt;/strong> par la valeur moyenne de l&amp;rsquo;accélération entre l&amp;rsquo;étape &lt;strong>n&lt;/strong> et une étape approximative &lt;strong>n+1&lt;/strong>.&lt;/p>
&lt;h5 id="avec-des-pas-de-distance-1">Avec des pas de distance&lt;/h5>
&lt;p>Même chose que la méthode d&amp;rsquo;Euler, sachant que &lt;em>x&lt;sub>n+1&lt;/sub>-x&lt;sub>n&lt;/sub>=h&lt;/em>, on obtient :&lt;/p>
&lt;p>$$v_{n+1}=\sqrt{v^2_n+2h\gamma}$$ &lt;div style="text-align: center"> &lt;strong>(9)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Avec :&lt;/p>
&lt;p>$$\gamma=\frac{\gamma_n(v_n)+\gamma_{n+1}(v^*_{n+1})}{2}$$&lt;/p>
&lt;p>$$v^*_{n+1}=\gamma_n(v_n)dt+v_n$$&lt;/p>
&lt;h4 id="la-méthode-rk4">La méthode RK4&lt;/h4>
&lt;h5 id="avec-des-pas-de-temps-2">Avec des pas de temps&lt;/h5>
&lt;p>La méthode Runge-Kutta 4 appliquée à l&amp;rsquo;intégration de l&amp;rsquo;équation du mouvement d&amp;rsquo;un train est :&lt;/p>
&lt;p>$$v_{n+1}=v_n+\frac{h}{6}(k_1+2k_2+2k_3+k_4)$$ &lt;div style="text-align: center"> &lt;strong>(10)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Avec :&lt;/p>
&lt;p>$$k_1=\gamma_n(v_n)$$ &lt;div style="text-align: center"> &lt;strong>(11)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$k_2=\gamma_{n+\frac{1}{2}}(v_n+\frac{h}{2}k_1)$$ &lt;div style="text-align: center"> &lt;strong>(12)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$k_3=\gamma_{n+\frac{1}{2}}(v_n+\frac{h}{2}k_2)$$ &lt;div style="text-align: center"> &lt;strong>(13)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>$$k_4=\gamma_{n+1}(v_n+hk_3)$$ &lt;div style="text-align: center"> &lt;strong>(14)&lt;/strong> &lt;/div>&lt;/p>
&lt;h5 id="avec-des-pas-de-distance-2">Avec des pas de distance&lt;/h5>
&lt;p>La même chose, mais cette fois :&lt;/p>
&lt;p>$$v_{n+1}=\sqrt{v^2_n+2h\gamma}$$ &lt;div style="text-align: center"> &lt;strong>(9)&lt;/strong> &lt;/div>&lt;/p>
&lt;p>Avec :&lt;/p>
&lt;p>$$\gamma=\frac{1}{6}(k_1+2k_2+2k_3+k_4)$$ &lt;div style="text-align: center"> &lt;strong>(15)&lt;/strong> &lt;/div>&lt;/p>
&lt;h4 id="quelle-méthode-choisir-">Quelle méthode choisir ?&lt;/h4>
&lt;h5 id="étude-de-la-précision-et-de-la-vitesse-de-calcul">Étude de la précision et de la vitesse de calcul&lt;/h5>
&lt;p>Différentes méthodes d&amp;rsquo;intégration auraient pu remplacer l&amp;rsquo;intégration d&amp;rsquo;Euler de base dans l&amp;rsquo;algorithme d&amp;rsquo;OSRD. Afin de décider quelle méthode conviendrait le mieux, une étude sur la précision et la vitesse de calcul de différentes méthodes a été menée. Cette étude a comparé les méthodes suivantes :&lt;/p>
&lt;ul>
&lt;li>Euler&lt;/li>
&lt;li>Euler-Cauchy&lt;/li>
&lt;li>Runge-Kutta 4&lt;/li>
&lt;li>Adams 2&lt;/li>
&lt;li>Adams 3&lt;/li>
&lt;/ul>
&lt;p>Toutes les explications sur ces méthodes peuvent être trouvées dans &lt;a href="https://github.com/DGEXSolutions/osrd/wiki/documents/integration/MethodesNumeriques_EricGoncalves.pdf">ce document&lt;/a>, et le code python utilisé pour la simulation est &lt;a href="https://raw.githubusercontent.com/wiki/DGEXSolutions/osrd/code/integration/Tests_precision.py">ici&lt;/a>.&lt;/p>
&lt;p>La simulation calcule la position et la vitesse d&amp;rsquo;un 2TGVDAZYEUM accélérant sur une ligne droite plate. L&amp;rsquo;intégration se fait en fonction du temps et non de la distance, car elle est beaucoup plus rapide à mettre en œuvre.&lt;/p>
&lt;h6 id="simulation-avec-les-mêmes-pas-de-temps">Simulation avec les mêmes pas de temps&lt;/h6>
&lt;p>Une courbe de référence a été simulée en utilisant la méthode d&amp;rsquo;Euler avec un pas de temps de 0,1s, puis les autres méthodes ont été simulées avec un pas de temps de 1s. Il est alors possible de comparer simplement chaque courbe à la courbe de référence, en calculant la valeur absolue de la différence à chaque point calculé. Voici l&amp;rsquo;erreur absolue résultante de la position du train sur sa distance parcourue :&lt;/p>
&lt;p>&lt;img src="../precisions_h_equivalent.png" alt="precisions_h_equivalent">&lt;/p>
&lt;p>Il apparaît immédiatement que la méthode d&amp;rsquo;Euler est d&amp;rsquo;environ d&amp;rsquo;un ordre de grandeur moins précise que les quatre autres. Chaque courbe présente un pic où la précision est extrêmement élevée (erreur extrêmement faible), ce qui s&amp;rsquo;explique par le fait que toutes les courbes commencent légèrement au-dessus de la courbe de référence, la croisent en un point et finissent légèrement en dessous, ou vice-versa.&lt;/p>
&lt;p>Mais comme la précision n&amp;rsquo;est pas le seul indicateur important, le temps de calcul de chaque méthode a été mesuré, et voici ce que nous obtenons pour les mêmes paramètres d&amp;rsquo;entrée (les valeurs sont en secondes) :&lt;/p>
&lt;p>&lt;img src="../time_h_equivalent.png" alt="time_h_equivalent">&lt;/p>
&lt;p>Ainsi, Euler-Cauchy et Adams 2 sont environ deux fois plus lents que Euler, Adams 3 est environ trois fois plus lent, et RK4 est environ quatre fois plus lent. Ces résultats ont été vérifiés sur des simulations beaucoup plus longues, et les ratios 2 et 3 sont maintenus.&lt;/p>
&lt;h5 id="simulation-avec-temps-de-calcul-équivalent">Simulation avec temps de calcul équivalent&lt;/h5>
&lt;p>Comme les temps de calcul de toutes les méthodes dépendent linéairement du pas de temps, il est assez facile de comparer la précision pour un temps de calcul à peu près identique. En multipliant le pas de temps d&amp;rsquo;Euler-Cauchy et d&amp;rsquo;Adams 2 par 2, le pas de temps d&amp;rsquo;Adams 3 par 3, et le pas de temps de RK4 par 4, voici les courbes d&amp;rsquo;erreur absolue résultantes :&lt;/p>
&lt;p>&lt;img src="../precisions_time_equivalent.png" alt="precisions_time_equivalent">&lt;/p>
&lt;p>Et voici les temps de calcul, en secondes :&lt;/p>
&lt;p>&lt;img src="../time_time_equivalent.png" alt="time_time_equivalent">&lt;/p>
&lt;p>Après un certain temps, RK4 tend à être la méthode la plus précise, légèrement plus précise que Euler-Cauchy, et toujours bien plus précise que la méthode d&amp;rsquo;Euler.&lt;/p>
&lt;h4 id="pourquoi-garder-runge-kutta-4">Pourquoi garder Runge-Kutta 4&lt;/h4>
&lt;h5 id="conclusions-de-létude-précédente">Conclusions de l&amp;rsquo;étude précédente&lt;/h5>
&lt;p>L&amp;rsquo;étude de la précision et de la vitesse de calcul présentée ci-dessus montre que RK4 et Euler-Cauchy seraient de bons candidats pour remplacer l&amp;rsquo;algorithme d&amp;rsquo;Euler dans OSRD : les deux sont rapides, précis, et assez faciles à mettre en œuvre car ils ne font que des calculs dans une étape courante. &lt;strong>Il a été décidé qu&amp;rsquo;OSRD utiliserait la méthode Runge-Kutta 4 parce qu&amp;rsquo;elle est légèrement plus précise que Euler-Cauchy et que c&amp;rsquo;est une méthode bien connue pour ce type de calcul, donc très adaptée à un simulateur open-source.&lt;/strong>&lt;/p>
&lt;h4 id="comparaison-des-méthodes-deuler-et-de-runge-kutta-4">Comparaison des méthodes d&amp;rsquo;Euler et de Runge-Kutta 4&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Méthode d&amp;rsquo;Euler&lt;/th>
&lt;th style="text-align:center">Méthode de Runge-Kutta 4&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;img src="../euler.png" alt="Méthode d&amp;amp;rsquo;Euler">&lt;/td>
&lt;td style="text-align:center">&lt;img src="../rk4.png?style=reduce" alt="Méthode de Runge-Kutta 4">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>Comparaison entre la méthode d’Euler et la méthode RK4; l’axe &lt;strong>x&lt;/strong> est le temps, l’axe &lt;strong>y&lt;/strong> est la vitesse résultante de l’intégration, k1, k2, k3, k4 sont les accélérations correspondent aux points indiqués (dérivatives de la courbe &lt;strong>v(t))&lt;/strong>.&lt;/p>
&lt;/blockquote>
&lt;p>La méthode Runge-Kutta 4, par opposition à une simple méthode d&amp;rsquo;Euler, est une bonne solution à nos besoins :&lt;/p>
&lt;ul>
&lt;li>Elle permet d&amp;rsquo;anticiper les futurs changements de directive, puisque nous calculons à chaque fois une estimation du prochain pas pour calculer l&amp;rsquo;accélération correspondante&lt;/li>
&lt;li>Elle est plus précise pour le même temps de calcul, permettant des étapes d&amp;rsquo;intégration plus grandes, donc moins de points de données et un temps de calcul plus rapide.&lt;/li>
&lt;/ul>
&lt;style>
img[src$="train"] {
height: 50%;
width: 50%;
}
img[src$="reduce"] {
margin-top: 15.5%;
}
&lt;/style></description></item><item><title>Users: Le système d'enveloppes</title><link>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/envelop_system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dgexsolutions.github.io/osrd-website/fr/users/docs/technical_and_physical_choices/envelop_system/</guid><description>
&lt;h4 id="une-interface-spécifique-dans-le-service-osrd-core--architecture">Une interface spécifique dans le service OSRD Core -&amp;gt;architecture&lt;/h4>
&lt;p>&lt;strong>1 - EnvelopePart :&lt;/strong> Courbe espace-vitesse, définie comme une séquence des points&lt;/p>
&lt;p>&lt;strong>2 - Envelope :&lt;/strong> Liste des EnvelopePart sur laquelle certaines opérations sont faisables :&lt;/p>
&lt;ul>
&lt;li>Vérifier la continuité dans l’espace (obligatoire) et dans la vitesse&lt;/li>
&lt;li>Chercher la vitesse min et/ou max&lt;/li>
&lt;li>Couper l’enveloppe&lt;/li>
&lt;li>Effectuer une interpolation de vitesse à une certaine position&lt;/li>
&lt;li>Calculer le temps écoulé entre deux positions de l’enveloppe&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>3 - Overlays :&lt;/strong> Système qui permet d’ajouter des EnvelopePart plus contraignantes à une enveloppe existante&lt;/p>
&lt;p>Pendant la simulation, le train est censé suivre certaines instructions de vitesse. Celles-ci sont modélisées dans OSRD par des courbes espace/vitesse appelées enveloppes. Il existe deux types d&amp;rsquo;enveloppes :&lt;/p>
&lt;ul>
&lt;li>Les enveloppes provenant &lt;strong>des données d&amp;rsquo;infrastructure et de matériel roulant&lt;/strong>, comme la vitesse maximale de la ligne et la vitesse maximale du train; étant des données d&amp;rsquo;entrée de notre calcul, elles ne sont pas exactes au sens physique du terme, car elles ne sont pas issues des résultats d&amp;rsquo;une intégration réelle des équations physiques du mouvement.&lt;/li>
&lt;li>Enveloppes résultant &lt;strong>d&amp;rsquo;une intégration réelle&lt;/strong> des équations du mouvement physique. Elles contiennent également des informations sur le temps.&lt;/li>
&lt;/ul>
&lt;h3 id="font-coloraa026dcomment-le-système-denveloppe-est-il-utilisé-dans-osrd-font">&lt;font color=#aa026d>Comment le système d&amp;rsquo;enveloppe est-il utilisé dans OSRD ?&lt;/font>&lt;/h3>
&lt;h4 id="calcul-de-marche">Calcul de marche&lt;/h4>
&lt;h5 id="calcul-du-temps-de-parcours-le-plus-rapide">Calcul du temps de parcours le plus rapide&lt;/h5>
&lt;p>Le premier objectif d&amp;rsquo;une simulation de train isolé est d&amp;rsquo;effectuer le calcul du &lt;strong>temps de parcours le plus rapide&lt;/strong>, où le train roule à la vitesse maximale autorisée. Pour y parvenir, une procédure composée de différentes étapes est utilisée. À chaque étape, de nouvelles enveloppes sont calculées et ajoutées aux précédentes. Nous appelons l&amp;rsquo;enveloppe finale résultante &lt;strong>Max Effort Envelope&lt;/strong> (Enveloppe de l&amp;rsquo;effort maximal).&lt;/p>
&lt;p>1 - Une première enveloppe est calculée au début de la simulation en regroupant toutes les enveloppes liées à certaines limites de vitesse statiques (vitesse maximale de la ligne, vitesse maximale du matériel roulant, limitations de vitesse temporaires, limitations de vitesse par catégorie de train, limitations de vitesse par essieu). Pour s&amp;rsquo;assurer que le train entier roule toujours à la vitesse autorisée, il faut prendre en compte l&amp;rsquo;entièreté de sa longueur $L$. Pour que la queue du train du train ne dépasse pas les limitations, on applique un &amp;ldquo;décalage&amp;rdquo; à la courbe poitillée rouge. L&amp;rsquo;enveloppe résultante (courbe noire) est appelée &lt;strong>Most Restricted Speed Profile (MRSP)&lt;/strong> (Profil de vitesse le plus restrictif).
&lt;img src="../mrsp.png" alt="Most Restricted Speed Profile">&lt;/p>
&lt;blockquote>
&lt;p>L’axe &lt;strong>x&lt;/strong> est la position du train, l’axe &lt;strong>y&lt;/strong> est la vitesse. La ligne pointillée rouge représente la vitesse maximale autorisée, la ligne noire est le MRSP où la longueur du train a été prise en compte.&lt;/p>
&lt;/blockquote>
&lt;p>2 - Toutes les courbes de freinage sont calculées en partant de leur point cible, c&amp;rsquo;est-à-dire le point dans l&amp;rsquo;espace où une certaine limite de vitesse est imposée (vitesse cible finie) ou le point d&amp;rsquo;arrêt (vitesse cible = 0 m/s). Les courbes de freinage sont calculées en considérant toutes les forces actives (force de freinage constante ou non, résistance à l&amp;rsquo;avancement, poids) et sont donc physiquement précises. L&amp;rsquo;enveloppe résultante est appelée &lt;strong>Max Speed Profile&lt;/strong> (Profil de vitesse maximale).
&lt;img src="../msp.png" alt="Max Speed Profile">&lt;/p>
&lt;p>3 - Pour chaque point correspondant à une augmentation de vitesse dans le MRSP ou à la fin d&amp;rsquo;une courbe de freinage d&amp;rsquo;arrêt, une courbe d&amp;rsquo;accélération est calculée. Les courbes d&amp;rsquo;accélération sont calculées en tenant compte de toutes les forces actives (force de traction, résistance à l&amp;rsquo;avancement, poids) et sont donc physiquement précises.&lt;/p>
&lt;p>4 - Pour toutes les parties de l&amp;rsquo;enveloppe qui ne sont pas physiquement exactes, une nouvelle intégration des équations de mouvement est effectuée. Ce dernier calcul est nécessaire pour reproduire le comportement correct des parties de l&amp;rsquo;enveloppe où la vitesse doit être maintenue à une valeur constante, en incluant l&amp;rsquo;effet de toutes les forces. L&amp;rsquo;enveloppe qui en résulte est appelée &lt;strong>Max Effort Profile&lt;/strong> (Profil d&amp;rsquo;effort maximal).
&lt;img src="../mep.png" alt="Max Effort Profile">&lt;/p>
&lt;h5 id="calcul-de-marche-avec-marges">Calcul de marche avec marges&lt;/h5>
&lt;p>Après avoir effectué le calcul de marche le plus rapide, il est possible d&amp;rsquo;y introduire certaines marges (allowances). Dans le calcul de marche d&amp;rsquo;OSRD, nous décidons de distribuer les marges d&amp;rsquo;une manière économique, en minimisant la consommation d&amp;rsquo;énergie pendant le parcours du train. Une nouvelle &lt;strong>enveloppe Eco&lt;/strong>, résultant d&amp;rsquo;un algorithme de dichotomie, est donc calculée pour distribuer une certaine valeur de marge dans l&amp;rsquo;enveloppe d&amp;rsquo;effort maximum calculée précédemment.
&lt;img src="../allowances.png" alt="Marges">&lt;/p>
&lt;h4 id="simulation-de-plusieurs-trains">Simulation de plusieurs trains&lt;/h4>
&lt;p>Dans le cas de la simulation de nombreux trains, le système de signalisation doit assurer &lt;strong>la sécurité&lt;/strong>. L&amp;rsquo;effet de la signalisation sur le calcul de marche d&amp;rsquo;un train est reproduit en superposant des enveloppes dynamiques à l&amp;rsquo;enveloppe statique. Une nouvelle enveloppe dynamique est introduite par exemple lorsqu&amp;rsquo;un signal se ferme. Le train suit l&amp;rsquo;enveloppe économique statique superposée aux enveloppes dynamiques, s&amp;rsquo;il y en a. Dans ce mode de simulation, un contrôle du temps est effectué par rapport à un temps théorique provenant de l&amp;rsquo;information temporelle de l&amp;rsquo;enveloppe économique statique. Si le train est en retard par rapport à l&amp;rsquo;heure prévue, il cesse de suivre l&amp;rsquo;enveloppe économique et essaie d&amp;rsquo;aller plus vite. Sa courbe espace/vitesse sera donc limitée par l&amp;rsquo;enveloppe d&amp;rsquo;effort maximum.&lt;/p>
&lt;p>Rajouter une partie Marge économique&lt;/p></description></item></channel></rss>